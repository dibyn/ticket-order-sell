Contents

- [**What is a microservice**](#what-is-a-microservice)
- [**Data in microservice**](#data-in-microservice)
- [**Big Problem with data**](#big-problem-with-data)
- [**Sync communication with between services**](#sync-communication-with-between-services)
- [**Event based communication**](#event-based-communication)
- [**Crazy way of storing data**](#crazy-way-of-storing-data)
- [**Pros and cons of async communication**](#Pros and cons of async communication)

# What is a microservice?

To answer this question, we're first going to do a quick review on how you are probably building servers right now.

So right now you are probably familiar with a monolithic architecture.
This is probably how you are building servers right now in a monolithic server.
We have all of our code needed to implement our application inside of one single code base, and we deploy that code base as one discrete unit.
So we might imagine that with a monolithic server we have some request coming from users, browser or mobile device that will flow into our application and go through maybe some pre processing middleware.
Then maybe it goes off to some router.
That router might then inspect the request and decide to send it off to some very specific feature to be further processed.
So maybe in this case it goes off to feature a feature A might decide to read or write some data out of a database, eventually formulate a response and then send a response back to whoever made the request.
So if we had to characterize a monolithic server, we might say the following.
We might summarize it with this sentence right here.
We would say that a monolith contains all the routing, all the middleware, all the business logic in all the database access code required to implement all features of our application.

So that would characterize a monolith.
So here's how we would characterize microservices.

We would say that a single microservice contains all of the routing, all the middleware, all the business
logic and database access required to implement one feature of our application.
That is the big difference.
So a monolith has all the code needed to implement every feature of our application.

**A microservice has all the code needed to implement just one feature.**

So with this microservice architecture, we've now split off all these different features and wrap them up inside of their own little personalized services.

**The very important thing here to understand is that each of these services are entirely self contained.**

So service right here has all of the code required to make feature a work correctly. It will has have its own database as well.

The nice thing about this approach is that if for some reason, if every other feature or every other
service inside of our application crashes or just mysteriously disappears, a portion of our app is still going to work just fine, as service, say is 100% standalone and doesn't necessarily require any other service to work correctly.

# Data in microservice

Data management between services.

When I say data management, I'm talking about the way in which we store data inside of a service and

how we communicate that data between different services. Let me take a pause right here and just tell you flat out this is a very big, very challenging problem. It is a huge obstacle to effectively using microservices.
The good news is that this problem right here is what we are going to have in unending focus on in this course.
And by the end of this course, you're going to have a couple of different strategies for working with this data management problem. So now let me tell you a little bit more about why this is a problem. Let me help you understand why this is such a big thing. So a little bit of preamble here, a little bit of background with microservices. The way in which we store data and access data is a little bit weird. And what I mean by weird is that it's just a little bit different than what you might be used to with a monolithic application. So in the next couple of diagrams, we're going to take a look at how we store data and how we access data in a microservices approach. So first off, how do we store data in a microservices system? We might recall the diagram we were looking at just a moment ago. I showed a separate database for every service that we had created. So whenever we are making use of microservices, we are going to create a separate database for each service.

If the service actually needs a database, if a **service d**oesn't need a database, that's fine. We're not going to give it one.
But the point is, every service gets its own database.
Now, that might sound really strange, but I'm going to give you a very good reason for this in just a moment.
First, let me also show you how we access data.
And once again, this is going to be a little bit strange.
So to access data, I'm not going to tell you exactly how we're going to access data. I'm going to tell you how we are not going to access data. So we are never going to access data by reaching from one service into another services database.
So under no circumstance will we ever have service, say right here, try to reach into the database for service B And once again, I'm going to give you a very good reason for this in just a moment.

**First off, each service is going to get its own database if it needs one.**

**And secondly, services are never going to reach into another service's database.**

Why are we doing this?

There's a couple of different reasons.

First, I want you to understand that this whole idea of giving every service its own database is known as a pattern.

The pattern is called **database per service**. So as you'd expect, that just means every service has its own database. So here are a couple of reasons, and this is by no means an exhaustive list. The first reason, and this is the really big reason, is that we want every service we create to run independently of other services.
So let me show you a quick diagram to help you understand why giving each service its own database is going to help with that.

So first, let's imagine a scenario where we have every service using the same common database. So maybe it's just one database right here. We'll call it database for everything.

The problem with this approach is that if anything bad ever happens to this database, all of our services are going to crash immediately.

The other big problem is that scaling this database right here would be really challenging.

If every service inside of our application uses the same database, we're going to have to scale up that one database instance or that one database to service all the different services of our app. It would be a lot easier to scale just the databases that need additional capacity or throughput.

The other scenario that we could run in. Let's imagine that we've got service a reaching out to database BES service right here. If anything ever goes wrong with the database, be right there. Then all of a sudden service is going to start to crash because we have introduced a dependency between service A and service B.

So if a request comes into service A and feature A tries to reach over to the database and something is wrong with that database, boom service is going to crash as well.
And so rather than just losing service B we would now also be losing service.
A So by given each date of each service+, its own database and making sure that each service only uses its own database, we dramatically increase the uptime of our entire system.

That's the next reason that we have this database per service pattern is that the schema or structure of a database might change unexpectedly.

So a quick example of this as well.

I want you to imagine for a second that we've got service A or reaching directly over to Database B over here.

And again, this is not what we want.

I'm giving you an example of why we do not do this.

So let's imagine that feature a usually runs a query of something like get user inside a, B, and usually database B returns an object that has a name of Jill or something like that, whatever the name is.

The point is that it's got a key of name right there.

And let's imagine that for some reason, Service B, the team that is in charge of it decides to change the schema or the structure of this database.

And maybe they decide that rather than giving every user a name property, maybe they want to call that first name instead.

Let's further imagine that maybe the team in charge of Service B does not tell the team and charge of Service A about the change to the schema right here.

If that were to happen, then the next time that service A makes a query down here, they're going to get back an object that has a first name property instead of name.

Service say was probably not configured to expect to see a property of first name.

And so now we might start to have some issues start to arise in service.

A All because we tried to rely upon a database located in a different service and that second database right there had its structure or schema change at some point in time.

Now, the last reason I'm going to throw out here really quickly is that some services might be able to function more efficiently if they are using a different type of database.

So, for example, maybe one service can run more efficiently if it uses Mongo or MongoDB as opposed to post grass or something similar to that.

This whole database per service pattern might seem a little bit surprising, and you might already be saying, Stephen, there's no way this is how it's done.

There's no way we're creating a separate database for every service.

Well, this is reality.

This is how every successful engineering team out there is using microservices.

They are all every last one of them following this pattern right here, one database per service.

So now that we've set up this kind of weird pattern right here, we still have not really touched on why data management between services is really challenging.

# Big Problem with data

In the last video, we discussed some reasons to have one database per service that we create. So now in this video, I want to kind of circle this whole idea back to something we looked at just a moment ago where I said that data management between services was really challenging. So we're going to take a look at a very simple application that we might try to build using this database per service approach. And you're going to see that very quickly. We run into some gigantic data management issues. Now, to help you understand this quick example, let's take a look at a little diagram here. So let's imagine that this is the application that we're going to build. So very simple in nature. It's an E commerce application and it really has just three very simple functions to it. First, we have the ability to sign up. We have the ability to list out some products that a user can buy, like hats, pants and shoes. And we have the ability to actually buy those products as well. Now, let's first imagine building this very simple application with a monolith style approach. So remember, with a monolith, we've got all of our code inside of one code base and we've got one database to service that. So here's a sort of monolithic style approach. We've got our monolithic server and it has some code to sign up user list available products and purchase a product. Now, of course, our monolithic server probably needs to store data somewhere, so maybe we create a database to service each of these different functions. So inside of this one singular database, we might have a collection or table of users, a collection or table of products, and the same for orders as well. Okay, this all looks pretty simple and straightforward. Let's now start to add in a new feature to our monolith. So let's say that we want to add in a new feature where we can show all the products ordered by a very particular user. How would we implement that thing? Well, if you really think about it, we kind of need information from all of these different collections or tables right here. First, we might want to take a look at the user collection and make sure that the particular user that we're trying to look up information for exists. We might try to then look in the orders collection and find the order that a user has created. And maybe on that order we would see the IDs of each product that was actually ordered. And if we want to to actually show information about those products, well, we probably have to do a query over to the products collection as well. So we're talking about accessing these three different sources of information to implement this one single feature and inside of a monolithic server. Yeah, this is all totally fine. No issue whatsoever. Okay. So now let's now take this entire idea right here, this simple e commerce application, but drop off that last feature. So how would we go back to this kind of scenario right here and split this monolithic server into three separate microservices? Well, it might look something like this right here. So we've got services that would have some code inside of it to sign up a user. And as we just discussed, it's going to have its own little database. So inside that database, we'll probably record all the users who sign up to our app. We'll have Service B for products and service C down here to purchase a product, which is really to like create a order and say that we want to purchase something. And so service B and C will probably have their own databases as well. Now let's imagine once again that we want to add in a new feature. So we want to add in a fourth service here service. D And the goal of **service D** is to give us the ability to show not products but orders made by a very particular user. So if we wanted to follow the same pattern that we used back in that monolith style approach, we could say that we want to have this service right here, reach out to that database. Reach out to database B and C. And it would have to do that if it wanted to get information about the user, find the order they had created, and then find details about those given products. But as we just discussed a moment ago, in this microservices style world, we do not allow a service to reach out to databases owned by other services. And so the question here very quickly becomes how would we create **service D**? How in the world would that happen? How could we somehow get information required to implement this feature right here without reaching into these databases? And that is the crux of the issue. That is why data management between services can be really, really challenging. Of course, there's a lot of other tiny little problems along the way, but that's kind of the core issue here. We don't allow these services to interact with each other's databases. And so any time we want to add in a new function or change functionality of an existing service and we want to get access to existing data, how do we do that? It's a challenging little problem. So let's take a pause right here. We're going to come back the next video. And I'm going to outline two general methodologies that we're going to use that would allow us to implement **Service D**

# Sync communication with between services

In the last video, we were looking at a very simple e-commerce application, and we saw that if we start to introduce this new **service d**own here that relies upon data from these other services, life starts to get really challenging really quickly. If we are going to follow that pattern of database per service because **service D** cannot reach directly over to this database, this one or this one. So in this video, we're going to take a look at two very general strategies that we can use to solve this problem. These two general strategies that we're going to use are really talking about how we communicate between different services. There are two general strategies referred to as synchronous or sync and asynchronous or async. I want you to understand right away that in the microservices world these terms do not mean what they mean in the JavaScript world. So JavaScript has its own definition of sync and async. That is not the same thing as sync and async in microservices, very different terms. So let's first begin by taking a look at the definition of a synchronous communication style. Okay. So in this synchronous world, if we are going to communicate between different services using this pattern, we're going to have one service, communicate with another directly using requests. This doesn't necessarily have to be an HTTP request or a request that exchanges JSON. It is just some kind of direct request, whatever its form is, a direct request from service a over to two service B to fetch some information. Rather than taking a look at the definition of async, let's first take a look at an example of synchronous communication right away. All right. So we're going to apply this idea of synchronous communication to the example that we were looking at just a moment ago. So once again, we are imagining this e-commerce application where we've got users, products and orders down here in Service C. So if we were going to use synchronous communication, we can imagine that a request might come into service. D And it might say, Show me all the products that have been ordered by the user with ID number one, the first thing that **Service D** might do is make a direct request over to service A Again, that might be a plain HTTP request. It might exchange JSON whatever its form is. It is a direct request from D over to a SO service. D would then check to make sure that maybe that user exists. It would then get a response back and if that user exists, it might then make a followup request over to service C and find all the orders that have been created for this user. It would get back a response and then finally make a request over to Service B and say, Give me details about these particular products. So after making those three different requests service T would then have all the information it needs to respond to the overall request. At no point in time did **service D** reach directly into any of these databases over here. So we have not violated any big rules around our database per service pattern. There's some definite upsides and downsides to this approach. So let's take a look at those right away. The upsides to this are that using synchronous communication is pretty easy to understand. I think that by pretty much just looking at this diagram, you've probably got a reasonable idea of how this stuff works. We create a service. It makes requests to other services to get data. That's it. So conceptually, not the worst thing. The other nice thing about this approach is that **Service D** is not going to need a database. So that's **service D** Right here. We won't have to provision maintain pay for a database. **Service D** relies upon data coming from these other services that have their own databases, so no database required. But like I said, there are some really big downsides to this approach as well. The downsides are, first off, it introduces a dependency between Service RD and those other three. That means that if any of these services go down for any reason, like, let's say, service A, if that goes down right there now all of a sudden **Service D** is not going to work correctly either. So **service D** is going to fail entirely as well. That means that we might lose the functionality of big pieces of our application at some point in time if some key critical service starts to go down. The next big issue is that if any of these enter service requests fail, the overall request is going to fail as well. So very similar to what we just said about service failing. If for some reason this request right here fails. Well, now we don't know if that user exists, so chances are we would throw an error and respond to the request and say sorry, but an error occurred. Can't help you. The next big downside is that this entire request is only as fast as the slowest request. So let's imagine that this request over to the user service right here takes, how, about ten milliseconds? And then maybe the next one down here to get all the products ordered by that person. Takes another ten milliseconds. And then finally, service. Be right here. Maybe for some crazy reason. That takes 20 seconds. So 20 seconds to make that final request right there. So that means that overall, we're going to have 20 and 20 milliseconds to complete the overall request. So we're only ever going to be as fast as the slowest request. And then finally, this one's a little bit hard to understand, but this can introduce a web of dependencies that starts to really spiral out of control. So the key thing to keep in mind around microservices, different diagram right here really quickly is that we don't necessarily know what some other service is doing internally. So if you and I are trying to develop **service D**, we might know that we need to make a request to A, B and C, but we might not know what those things are doing internally. And it turns out that service say internally to work correctly might need to make its own request over to service queue and service queue in turn might need to make its own request to Z and X down here. And so you can really start to imagine that to service any given request, like the one coming from service. D Right here, there might be a huge multitude of requests going on behind the scenes. Dozens, if not hundreds of requests just to service this one simple original request that came in to D. And once again, if any of these things go wrong, like if that fails right there or if that fails right there, well, all of a sudden the entire overall request fails as well. And once again, we're only as fast as the slowest operation. So in practice sync communication. Well, there are some definite upsides, but there are some gigantic operational downsides as well. Okay. So we've now got a pretty reasonable understanding of synchronous communication. And so that just leaves async.

# Event based communication

In this video, we're going to take a look at communication between services using an asynchronous communication style.
We're going to take a look at two different ways of using async communication. Okay.

**So the general idea between asynchronous communication is that we're going to introduce something into our entire application that is accessible from all these different services, refer to this thing as an event bus. The goal of this event bus is to handle little notifications or events being emitted from our different services.**

**These different notifications or events are like little objects you can imagine, like little notes that describe something that has happened or something that needs to happen inside of our overall application. Each service is going to connect to this event bus once it is connected. Each service can either emit events or receive events from the event bus.**

Now, one thing you might notice right away is that we've got all of our services wired up to one common thing right here, which means that we've got a single point of failure. So whenever we deploy an event bus, we usually go through a decent amount of effort to make sure that this thing is relatively resilient and it's not going to crash all the time and therefore restrict communication between our services.

Let's start to walk through an actual example of how we can use an event bus and emit events to solve this issue around **service D** So we're going to imagine that **Service D**HH receives a request asking to see all the products that have been ordered by a particular user. **Service D** needs information from services A, B, and C to complete this request. So the first thing that **service D** will do is emit an event. So this is an event right here. An event might have some type that describes what kind of event is occurring and it might have some data or contextual information associated with it as well. So in this case, we might imagine that the type is something like user query and the data might be the ID of the user that we want to look up. As a reminder, we're trying to make sure that whenever someone asks for information about a particular user, we're going to make sure that that user actually exists first. So this event would flow on over to this event bus. The event bus can automatically handle incoming events and route them off to different services that might be able to handle that event. So in this case, we might be able to configure our event bus to send a copy of this event over to service A and so we can imagine that this event is going to flow over like so. Then inside of service? A We would have some code to be executed any time this event comes in. So service might see this event come in. It might say, Oh, someone's trying to look up some information about a user. So service A could then look up information about the user with ID number one and then to respond or get some information back over to **service D**. Service A could emit a new event so it could emit an event over to the event bus. And maybe it would be an event with a type of something like user query result and then the data could be the actual information about this user. So maybe their ID and a name of Jill and whatever else. So this event would flow into our event bus and the event bus. We could configure it so that it will send an event of type user query results automatically back over to **service D**. So we'll go back over to **Service D**. And we'll have some code inside of **service D** to receive an event of type user queries and do some processing on it. You can then kind of imagine that we would repeat the same exact process to take a look at all the different orders that this user has created and then retrieve details about all the different products associated with those orders as well from Service B. So that is one possible way of doing asynchronous communication using events. Now I want to repeat again right away that you're not really going to see this used terribly often in the wild, and there's a very good reason for that. The reason is it basically shares all the downsides of synchronous communication, but it has additional downsides associated with it. So first off, I would say that this is conceptually not super easy to understand. **Service d**oesn't need a database. Yeah, that's still true. But with this style of asynchronous communication, we still have a dependency between services. If any of these events fails to be processed, the overall request is going to fail or probably time out. We still can only get a request or response back to the original request as quickly as the slowest event. And once again, we can easily be introducing a web of different events being emitted. So this style of asynchronous communication not the best thing in the world, but again, you still need to know that this exists. So that really just leaves us with one last option. Remember just a moment ago, I told you that there were two possibilities of using asynchronous communication to solve the issue that we're in right now. So let's take another pause right here. We'll come back the next video, and we'll take a look at the second form of asynchronous communication that we're going to use.

# Crazy way of storing data

We've now seen how to communicate between different services using synchronous and asynchronous communication. We're now going to take a look at a second way of using asynchronous communication. Now, I'm going to tell you right now that the second way that we're going to look at is going to be a little bit similar to the database for service pattern in that this stuff is going to seem really bizarre and pretty inefficient. But just bear with me.
We're going to go through a pretty deep example to give you an idea of how we're going to use asynchronous communication to somehow communicate between these different services.
We're going to once again focus on this idea of introducing **service D** into our E Commerce application that just has three existing services.

_The first thing I want to do is to put a better goal or really define exactly what we want **Service D** to do_.

Right now we're just saying, Oh yeah, we're going to show products ordered by a particular user. But I want to be really explicit in saying here are the inputs to this service and here is what is expected to respond with whenever it receives a request. So here's my more exact definition of what **service D** is supposed to do.

_I'm going to say that given the ID of a user, I want to show the title and image for every product that they have ever ordered. That's the exact, precise goal of_ **service D**. So now with that in mind, let's try to imagine creating a database that would serve this goal right here really well. So here's my idea of how we could add in a database to **service D** to solve this little feature request. So I think that we could introduce a database. It could be no SQL or SQL based. Doesn't really matter with two separate collections of data. One would be a record of all the different users who have signed up to our application. We don't really care about a user's email address. We don't care about their name. We don't care about their age or address. The only thing we said for our service as an input is that we need to know the idea of a user and then show products that they have ordered. So inside of this user's collection, I would record the ID of every user who signs up to my app and then the IDs of any products that they ever order. And then to actually know what the title and image is for every product. I could have a separate collection of products where a record the ID of the product, its title and its image. So if I put in some practical data here, I might end up with something like this. Maybe I would have an ID of five and 20 or some products, and I would have a title of say pants and shoes and an image of pants. JPEG and shoes. Dot jpeg. And then maybe if some user came along and ordered some product, maybe they have an idea of one. That's the idea of my user. And if they ordered products five and 20, I could store those inside of an array like so. So now can we answer this question? Can we fulfill this feature using this database? Well, let's walk through it again. So if I have the idea of a user, let's say that's user with ID one, I need to show the title and image for every product they have ever ordered. Okay, so we would go into our users collection, we'd find the user ID one, we'd find that the product IDs they have ordered are five and 20. So we then go and look inside of our product collection. We would find a product with five and 20, look at the appropriate title, an image for both, and then respond with both those to some incoming requests to **service D**. Well, it seems like that solves the issue. So if we had a database with this structure right here, we could implement **service D** very easily. And what's more, **Service D** would be 100% self contained. So this really turns into a question of how can we create this database and stick in the relevant information inside there? That is a challenge in its own right. And the reason for that is that if we think about the overall structure of our application right now, **Service D** is never really going to be told about whenever a user signs up. Whenever a product gets created or whenever a user orders a given product because that information is being sent in request to service A, B and C and output from all that is never making its way over to service. D. So right now it'd be kind of hard to get any relevant information into this database that we just imagined. So that's what we need to solve. We need to think how we can tell get service A, B, and C to somehow tell **service D** about any time a user signs up product is created or a user orders a product. And what's more, whenever service A, B, and C communicates that over, we need to figure out how to do that communication in some kind of way where Service A isn't going to fail if **Service D** is not up. So in other words, if we try to use some synchronous communication to have service a tell **service D** whenever a user signs up, well, once again, that's a dependency. If that request failed for some reason, who knows, service might crash as well. That's all of our requirements put together. So how are we going to solve this? Well, it's going to come down to that form of asynchronous communication. So let's go through this process. So we're going to imagine the workflow of how we would get information into our database right here. Here is exactly what would happen. Any time a request comes in to create a product, to sign up a user, or to create a or purchase a product, create an order. We're going to have these relevant services, emit an event simultaneously describing what just happened to them. Let me show you what I mean. Let's first imagine that we boot up our application for the very first time and we decide to go into our app and create a couple of different products. So maybe we make a request to service B. But the goal of creating a product internally service be would say, okay, I got this request, I'm going to create a product and save it into my personal database simultaneously. And here's the key service. B would also emit an event over to our service bus, and that event might look a little something like this. Let me zoom in so you can see this more easily. So service. Be right. After saving that new product might even emit an event that says, Hey everybody, if anyone cares, a product was just created. And here are some details about that product. Maybe it has an ID title and an image. So that event would flow into our event broker over here. So here's the event bus or event broker. The event bus would then take that event and send it off to any interested services. So in this case, that would be **service D**. So service would receive this event. We would have some code inside there to receive this event and **service D** would say, okay, a product was created as ID of $1 pants, an image of pants JPEG. So **Service D** would take that information and record that event inside of its products table. So ID put in, say, ID of one. By dollar pants and pants. JPEG. So that's how we would start to get some information into this database. We are going to rely upon these other services. A, B, and C emitting events any time something interesting occurs. So let's now go through the same process and imagine what would happen whenever a user signs up to our application. So let's imagine a little bit later after we create that product. And I'll update some terminology here. Here we go. So maybe a little bit later a user comes and signs up to our application. So we get a request to. Sign up that would come into our service. A service A would create a new user inside of its users collection, and then it would emit an event over to this event bus and maybe you would look something like a type of user created. And maybe as some data, it would have just the idea of the user that was created. So once again, this event would flow over to the event bus. The event bus would send that event along to **service D** down here. Inside of service. RD We would have some code to interpret this event. We would say, okay, a user was just created. Well, I'm going to save them as a user to my users collection. I've put down an idea one, and right now this user has not ordered any products, so maybe just put in an empty array of product IDs. Now I think you can understand where this is going. It's down the last step, we would imagine really quickly. That we get a request to order a product. So that would go to service. See? I won't change any terminology on this little thing right here just to save time. But we'd say that request would come into service C, service C would say, okay, I'll create a new order inside of some collection and then emit an event. And maybe that event would look something like order created and it might have some information tied to it, like the idea of the user and the ID of the product that was created as well. So we would have that event flow off to our event bus that would come into our service RD. Over here. Once again, **service d**ecals say OC order was created. It looks like user of ID one ordered a product with ID one, so it would update this products ID array right there, put in the one and there we go. We've now got our database fully populated and **service D** can instantly very quickly answer the question what products has a user with ID number one ordered? Okay. So that is asynchronous communication, that kind of second form that we're going to look at. And this has been a very long video, so we're going to take a pause right here and then do a summary and talk about some pros and cons. This approach in the next video.

# Pros and cons of async communication

In the last video, we walked through a second form of asynchronous communication. That was pretty darn crazy. Remember, I did tell you at the start of the video that this pattern was going to seem a really bizarre and inefficient. But before we entirely walk away from this pattern, let's take a look at some pros and cons and get a better idea of whether or not this is really something you want to try out. Okay. So here are some pros and cons. So on the plus side of this approach, service RD has zero dependencies on other services. Now, when I say zero dependencies, I'm talking about what happens whenever a request comes into service. RD Can service RD answer some request? About what products a user has ordered without reaching out to any other service. The answer is yes. Service does not have immediate need of any other service to answer an incoming request. It does rely upon other services to get some information to store inside this database. But those are kind of indirect dependencies. If service A, B and C go down. And they entirely disappear. Service RD is still going to work 100% correctly every single time. And so we would say that service DX it really doesn't have any other dependencies. The other big benefit here is that Service DX is going to be extremely fast compared to the other two approaches that we looked at. And the reason for that is that Service DX has all the products that a user has ordered inside of an immediately available database. And so it could reach into this database, grab some information and immediately respond to some request. And it can do that once again without having to make a direct request to services A, B or C. Now. How about the downsides? Well, the downside here is data duplication. We are now talking about directly duplicating data between different services.

Remember, the entire key here was that whenever a request came in to sign up a user to create a product or to purchase a product, those services were going to store information about an order, about a product or that user signing up inside of its own local database. And then we took it that information about the user that is created or the product or the order and also stored it inside of the second database down here. Now, we did not actually store the entire record per se. That's why back here when we spoke about really refining the requirements, we said specifically the title and the image for every product. So a product might also have information about its price, its reviews, all that kind of other stuff. And we're only storing the title and the image. So we're not strictly 100% duplicating data, but certainly there is some duplication occurring here. Now, that might sound like a really bad thing because, hey, we're paying for some extra storage, but I'm going to come down really hard on you, really hard if you come into the discussion and you complain about paying for extra storage. So let me tell you why right now. Let me put to rest any concerns about paying for extra storage. We're going to do a quick aside here. So I did a little bit of research right now at the time I'm recording this video in order to get a gigabyte worth of storage using Azure, my SQL or Google Cloud, my SQL or AWS, my SQL. It's one to me 11 and a half cents on Azure. It's $0.17 and 11 one half cents on A to B to get one gigabyte of storage for one month. So that's kind of a metric. That's how much we have to pay for each of these providers to get one gigabyte of storage for one month. So I was kind of curious, how much does it really cost to store the idea of some product? Well, inside of this blue box right here, you're going to see a ton of really tiny text. So what that is right there is the API response from AWS or really Amazon with all the information about some product that they are selling. So this is the definition of a product according to Amazon for something they are actually selling. So this is some pretty realistic information right here. So I was kind of curious, what does what is the size of that information? The information for one single product? You'll notice that this is JSON data. And so inside of here is a lot of keys and double quotes and curly braces and whatnot, and that is all information that would normally not be stored inside of a database. But I said, what the heck? Worst case scenario, what is the size of that information right there? It turns out that it's about 1200 bytes or so. So we did a little calculation. I said, okay, we got 1200 bytes or so. That's that many gigabytes times one and one half cents per gigabyte per month. And then I figured, what would it cost to store 100 million products that were this size inside of some database? And the answer is $14 100 million products, $14, and we afford $14 to store some extra data inside of a microservices application. The answer is unequivocally yes. And for extra storage, that is not a downside because storage in the modern world is relatively free. So for me, data duplication, maybe we are going to end up with some stale data over time, which is something that we are going to discuss later on. But as far as the price, no, that's that's not a cause for concern. Period. All right. So now the last one here. Last downside. Hard to understand. Yeah, I would definitely say so. This entire idea of having all of our services emit events and then listening for events, that is a lot of overhead. That's a lot of extra code for us to write, a lot of extra stuff to understand. So there are some definite downsides to this approach. But as far as providing a superior performance and uptime for our users, this form of asynchronous communication, no two ways about it. This is the way to go. And so, as you can probably guess in this course, we're going to focus on this form of asynchronous communication. We're going to create a lot of different services that are going to have incoming requests. The service is going to do something locally with that request, and if it makes a change to any data, it's going to emit an event. Other services will then wait on around, listen for events to come in and eventually populate databases that look like this right here to answer some very specific queries. All right. So now that we've got some idea of this form of async stuff, let's take a pause right here. We're going to start working on our first project in the next video.
